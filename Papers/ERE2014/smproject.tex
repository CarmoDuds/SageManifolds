\documentclass[a4paper]{jpconf}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{amssymb,amsfonts} % AMS Symbols


\newcommand{\soft}[1]{\texttt{#1}}
\newcommand{\code}[1]{\texttt{#1}}
\newcommand{\Sage}{\soft{Sage}}
\newcommand{\SM}{\soft{SageManifolds}}
\newcommand{\be}{\begin{equation}}
\newcommand{\ee}{\end{equation}}

\begin{document}
\title{Tensor calculus with free software: \\
the SageManifolds project}

\author{Eric Gourgoulhon$^1$, Micha\l{} Bejger$^2$, Marco Mancini$^1$}

\address{$^1$ Laboratoire Univers et Th\'eories, UMR 8102 du 
CNRS, Observatoire de Paris, Universit\'e Paris Diderot,
92190 Meudon, France}

\address{$^2$ Centrum Astronomiczne im. M. Kopernika, ul. Bartycka 18,
00-716 Warsaw, Poland}

\ead{eric.gourgoulhon@obspm.fr}

\begin{abstract}
Abstract
\end{abstract}

\section{Introduction}

Computer algebra for general relativity (GR) has a long history, which started
almost as soon as computer algebra itself in the 1960s. 
The first GR software was \soft{ALAM} (for \emph{Atlas Lisp Algebraic Manipulator})
witten by R.A. d'Inverno in 1969, who used it to compute
the Riemann and Ricci tensors of the Bondi metric. The original calculations took Bondi and his collaborators 6 months to go. The computation with \soft{ALAM} took 4 minutes and yield to the discovery of 6 errors in the original paper \cite{Skea94}. 
Since then, many packages have been developed and the reader is refered to \cite{MacCa02}
for a review of computer algebra
systems for GR prior to 2002 and to \cite{KorolKS13} for a more recent review,
focussing on tensor calculus, as well as to the semi-exhaustive list of
tensor calculus packages at \cite{xact_links}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Software for differential geometry}

Software packages for differential geometry and tensor calculus can be 
classified in two categories: 
\begin{enumerate}
\item Applications atop general purpose computer algebra systems; 
notable examples are 
the \soft{xAct} suite \cite{Marti08,xAct} and \soft{Ricci} \cite{Ricci}, both
running atop \soft{Mathematica},
\soft{DifferentialGeometry} \cite{AnderT12,DiffGeom} integrated into \soft{Maple}, and \soft{Atlas 2}
\cite{Atlas2} for both \soft{Mathematica} and \soft{Maple}.
\item Standalone applications; recent examples are \soft{Cadabra} \cite{Peete07,Cadabra} (field theory),
\soft{SnapPy} \cite{SnapPy} (topology and geometry of 3-manifolds) and
\soft{Redberry} (tensors) \cite{BolotP13,Redberry}.
\end{enumerate}
All applications listed in the second category are free (open-source) software. In
the first category, \soft{xAct} and \soft{Ricci} are also free software, but
they run atop a proprietary product, the sources of which are closed (\soft{Mathematica}). 

As far as tensor calculus is concerned, the above packages can be distinguished by 
the type of computation that they perform: abstract index manipulations 
(\soft{xAct/xTensor}, \soft{Ricci}, \soft{Cadabra}, \soft{Redberry})
or component calculus (\soft{xAct/xCoba}, \soft{DifferentialGeometry}, \soft{Atlas 2})
In the first category, tensor operations such as contraction or covariant differentiation 
are performed by manipulating the indices themselves rather than the components 
to which they correspond. In the second category, vector bases are explicitely 
introduced on manifolds and tensor operations are carried out on the components 
in a given basis.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{An overview of Sage}

\Sage{} \cite{sage} is a free open-source mathematics software system, which is
based on the Python programming language. It makes use of 90 open-sources packages, 
among which \soft{Maxima} and \soft{Pynac} (symbolic calculations),
\soft{GAP} (group theory), 
\soft{PARI/GP} (number theory), \soft{Singular} (polynomial computations), 
and \soft{matplotlib} (high quality 2D figures). 
\Sage{} provides a uniform Python interface to all these packages; however, 
\Sage{} is much more than a mere interface: it contains a large and increasing part of 
original code (more than 750,000 lines of Python and Cython, involving 5344 classes). 
\Sage{} has been created in 2005 by W. Stein \cite{SteinJ05} and since
then its development has been sustained by more than a hundred researchers
(mostly mathematicians). Good introductory textbooks about \Sage{} are
\cite{JoyneS14,Zimme13,Bard15}. 
 
Apart from the syntax, based on Python and not on some specific script 
language, a difference between \Sage{} and \soft{Maple} or \soft{Mathematica}
is the use of the \emph{Parent/Element} scheme, which makes \Sage{} closer to 
actual mathematics. For instance, in \soft{Mathematica}, all objects 
are trees of symbols and the language is essentially a set of 
sophisticated rules to manipulate the symbols. On the contrary, in \Sage{}
each object has a given type (i.e. is an instance of a given Python class), 
and one distinguishes \emph{parent} types, which model mathematical
sets with some structure (e.g. algebraic structure), from \emph{element} types,
which model set elements. 
In particular, calculus rules on elements are determined by the algebraic
structure of their parents. Automatic conversion rules, called \emph{coercions},
prior to a binary operation, e.g. $x+y$ with $x$ and $y$ having different 
parents, are defined at the level of the parents.

\section{The SageManifolds project}

\subsection{Aim and scope}

\Sage{} is well developed in many areas of mathematics but there is
very little for differential geometry and tensor calculus.
The aim of \SM{} is to introduce differential manifolds and tensor fields
in \Sage{}, and to do it in a coordinate-independent manner. 
More precisely, one should not to stick to a single coordinate patch
but should be able to introduce various coordinate charts
on a manifold. Tensor fields must be manipulated as such and not through 
their components with respect to a specific (possibly coordinate) vector frame. 

Basically the work amounts to creating new Python classes\footnote{Let us
recall that within an object-oriented programming language (as Python is),
a \emph{class} is a structure to declare and store the
properties common to a set of objects; these properties 
are data (called 
\emph{attributes} or \emph{state variables}) and functions acting 
on the data (called \emph{methods}); a specific realization of an object 
within a given class is called an \emph{instance} of that class.},
 such as 
\code{Manifold}, \code{Chart}, \code{ScalarField} or \code{TensorField},
and to implement them within the Parent/Element scheme. 
For instance the class \code{Manifold}, devoted to real smooth manifolds,
is a parent class, which means that it inherits from Sage native class \code{Parent}.
On the other hand, the class devoted to manifold points, \code{Point}, 
is an element class and therefore inherits from Sage native class 
\code{Element}.
This is illustrated by the inheritance diagram of Fig.~\ref{f:domain_classes}.
In this diagram, each class at the base of an arrow is a subclass (also
called \emph{derived class}) of the class at the arrowhead.

\begin{figure}
\begin{center}
\includegraphics[width=0.7\textwidth]{domain_classes.pdf}
\end{center}
\caption{\label{f:domain_classes} Python classes for 
smooth manifolds (\code{Manifold}), generic subsets of them 
(\code{Domain}), open subsets of them (\code{OpenDomain})
and points on them (\code{Point}).}
\end{figure}

\subsection{Implementation of charts}

Given a manifold $\mathcal{M}$ of dimension $n$, a coordinate chart 
on an open subset $U\subset\mathcal{M}$ is implemented in \SM{} 
via the class \code{Chart}, whose main data is 
a $n$-uple of \emph{\Sage{} symbolic variables} \code{x}, \code{y}, ..., each of 
them representing a coordinate.
In general, more than one (regular) chart is required to cover the entire manifold.
For instance, at least 2 charts are necessary to cover the $n$-dimensional sphere 
$\mathbb{S}^n$ and 3 charts are necessary to cover the real projective plane
$\mathbb{RP}^2$. 
Within \SM{}, an arbitrary number of charts can be introduced.
To fully specify the manifold, one shall also provide the \emph{transition maps} on
overlapping chart domains (\SM{} class \code{CoordChange}).

\subsection{Implementation of scalar fields}

A \emph{scalar field} on manifold $\mathcal{M}$ is a smooth mapping
\be
    \begin{array}{lcll}
    f: & U\subset \mathcal{M}&\longrightarrow &\mathbb{R} \\
       & p & \longmapsto  & f(p)
    \end{array}
\ee
where $U$ is an open subset of $\mathcal{M}$.
Note that a scalar field maps \emph{points}, not \emph{coordinates}, to real numbers. 
A scalar field $f$ has different coordinate representations $F$, $\hat F$, etc. 
in different charts $C$, $\hat C$, etc. defined on $U$:
\be
    f(p) = 
F(\underbrace{x^1,\ldots, x^n}_{\mbox{coord. of $p$}\atop\mbox{in chart $C$}}) 
= {\hat F}(\underbrace{{\hat x}^1,\ldots, {\hat x}^n}_{\mbox{coord. of $p$}\atop\mbox{in chart $\hat C$}})
= \ldots
\ee
These representations are 
stored in an attribute of the class \code{ScalarField} that is a 
Python dictionary\footnote{a data structure that is an associative mapping},
whose keys are the charts:
\be
 f.\mbox{\texttt{\_express}} = \left\{ C: F,\ \hat C: \hat F, \ldots \right\} .
\ee


\ack
This work has benifited from enlightening discussions with Volker Braun,
Vincent Delecroix, Simon King,  Jos\'e M. Mart\'\i n-Garc\'\i a, 
S\'ebastien Labb\'e,
Marc Mezzarobba, Thierry Monteil, Travis Scrimshaw and Nicolas Thi\'ery. 
We also thank St\'ephane M\'en\'e for his technical help. 
 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section*{References}
\begin{thebibliography}{10}
\bibitem{Skea94}
Skea J E F 1994 Applications of SHEEP {\it Lecture notes available at}
\url{
http://www.computeralgebra.nl/systemsoverview/special/tensoranalysis/sheep/}
\bibitem{MacCa02}
MacCallum M A H 2002 {\it Int. J. Mod. Phys. A} {\bf 17}, 2707 
\bibitem{KorolKS13}
Korol'kova A V, Kulyabov D S and Sevast'yanov L A 2013 {\it Prog. Comput. Soft.} 
{\bf 39}, 135
\bibitem{xact_links} 
\url{http://www.xact.es/links.html}
\bibitem{Marti08}
Martin-Garcia J M 2008 {\it Comput. Phys. Commun.} {\bf 179}, 597
\bibitem{xAct}
\url{http://www.xact.es}
\bibitem{Ricci}
\url{http://www.math.washington.edu/~lee/Ricci/}
\bibitem{AnderT12}
Anderson I M and Torre C G 2012 {\it J. Math. Phys.} {\bf 53}, 013511
\bibitem{DiffGeom}
\url{http://digitalcommons.usu.edu/dg/}
\bibitem{Atlas2}
\url{http://digi-area.com/Maple/atlas/}
\bibitem{Peete07}
Peeters K 2007 {\it Comput. Phys. Commun.} {\bf 15}, 550
\bibitem{Cadabra}
\url{http://cadabra.phi-sci.com/}
\bibitem{SnapPy}
Culler M, Dunfield N M and Weeks J R, SnapPy, a computer program for studying the geometry and topology of 3-manifolds, \url{http://snappy.computop.org}
\bibitem{BolotP13}
Bolotin D A and Poslavsky S V 2013 Introduction to Redberry: the computer algebra system designed for tensor manipulation {\it Preprint} arXiv:1302.1219
\bibitem{Redberry}
\url{http://redberry.cc/}
\bibitem{sage}
\url{http://sagemath.org/}
\bibitem{SteinJ05}
Stein W and Joyner D 2005 {\it Commun. Comput. Algebra} {\bf 39}, 61
\bibitem{JoyneS14}
Joyner D and Stein W 2014 {\it Sage Tutorial} (CreateSpace)
\bibitem{Zimme13}
Zimmermann P et al. 2013 {\it Calcul math\'ematique avec Sage} (CreateSpace); 
freely downloadable from \url{http://sagebook.gforge.inria.fr/}
\bibitem{Bard15}
Bard G V 2015 {\it Sage for Undergraduates} (Americ. Math. Soc.) in press;
preprint freely downloadable from \url{http://www.gregorybard.com/})
\end{thebibliography}

\end{document}
